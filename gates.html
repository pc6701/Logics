<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Function → Logic Circuit Converter</title>

  <!-- Bootstrap & jQuery -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

  <style>
    :root {
      --accent: #0d6efd;
      --card-bg: rgba(255, 255, 255, 0.75);
      --muted: #6c757d;
      --wire: #333;
    }
    body {
      background: linear-gradient(135deg, #dbeafe, #fef9c3);
      font-family: 'Inter', system-ui, "Segoe UI", Roboto, Arial;
      min-height: 100vh;
    }
    .app {
      max-width: 1100px;
      margin: 40px auto;
    }

    /* HEADER */
    header {
      background: linear-gradient(90deg, #0d6efd, #2563eb);
      padding: 16px 24px;
      border-radius: 14px;
      color: #fff;
      box-shadow: 0 6px 20px rgba(0,0,0,0.1);
    }
    header .title {
      display: flex;
      align-items: center;
      gap: 16px;
    }
    header img {
      background: rgba(255,255,255,0.2);
      padding: 6px;
      border-radius: 10px;
    }

    /* INPUT CARD */
    .input-row {
      margin-top: 20px;
      background: var(--card-bg);
      border-radius: 14px;
      padding: 18px 20px;
      backdrop-filter: blur(12px);
      box-shadow: 0 6px 24px rgba(0,0,0,0.06);
    }
    .form-control {
      font-size: 1.05rem;
      border-radius: 10px;
    }
    .controls .btn {
      border-radius: 10px;
      transition: all .2s ease;
    }
    .controls .btn:hover {
      transform: translateY(-2px);
    }
    .hint {
      font-size: 0.9rem;
      color: var(--muted);
      margin-top: 6px;
    }

    /* CIRCUIT RENDER AREA */
    .circuit-wrap {
      margin-top: 24px;
      background: var(--card-bg);
      border-radius: 14px;
      padding: 18px;
      min-height: 360px;
      box-shadow: 0 8px 28px rgba(0,0,0,0.08);
      backdrop-filter: blur(12px);
    }
    svg {
      width: 100%;
      height: 380px;
      overflow: visible;
    }
    @media (max-width: 700px) {
      svg { height: 520px; }
    }

    /* FOOTER / DOWNLOAD */
    .download-row {
      margin-top: 12px;
      border-top: 1px solid rgba(0,0,0,0.05);
      padding-top: 12px;
      font-size: 0.9rem;
    }
    #btnDownload {
      border-radius: 10px;
    }
  </style>
</head>
<body>
  <div class="app container">

    <!-- HEADER -->
    <header class="mb-4">
      <div class="title">
        <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='36' height='36'><rect rx='6' width='36' height='36' fill='%23fff' opacity='0.2'/><text x='50%' y='58%' font-size='20' text-anchor='middle' font-family='Arial' fill='white'>ƒ</text></svg>" alt="icon">
        <div>
          <h4 class="mb-0 fw-bold">Function → Logic Circuit Converter</h4>
          <small class="opacity-75">Enter Boolean expressions: adjacency = AND, + = OR, ' = NOT</small>
        </div>
      </div>
    </header>

    <!-- INPUT AREA -->
    <div class="input-row">
      <div class="row g-2 align-items-center">
        <div class="col-md-9">
          <input id="expr" class="form-control" placeholder="Example: A(B+C') + D E' " value="A(B+C')">
          <div class="hint">Variables: A–Z. Use <code>'</code> for NOT (complement), <code>+</code> for OR, adjacency for AND. Parentheses supported.</div>
        </div>
        <div class="col-md-3">
          <div class="controls d-flex gap-2">
            <button id="btnConvert" class="btn btn-primary w-50">Convert</button>
            <button id="btnClear" class="btn btn-outline-secondary w-50">Clear</button>
          </div>
        </div>
      </div>
    </div>

    <!-- CIRCUIT RENDER AREA -->
    <div class="circuit-wrap mt-4">
      <div id="canvasArea" class="position-relative">
        <svg id="circuitSVG" viewBox="0 0 1200 400" preserveAspectRatio="xMinYMid meet"></svg>
      </div>
        
        <!-- FOOTER -->
  <footer>
    <p class="text-center">⚠️ For best experience, please open in <strong>Desktop Mode</strong>.</p>
    <span class="text-center text-muted">&copy Developed by SAM Chauhan</span>
  </footer>
  
      </div>
    </div>
  </div>

  <!-- JavaScript (unchanged from your version) -->
  <script>
/* ---------------------------
   Parser -> AST
   Supports: variables A-Z, ', +, implicit AND, parentheses
   Grammar (informal):
     Expression := Term ( '+' Term )*
     Term := Factor ( Factor )*          // adjacency = AND
     Factor := VAR ['] | '(' Expression ')' [']  // NOT can follow a var or group
----------------------------*/

function tokenize(s){
  const out=[]; s = s.replace(/\s+/g,'');
  for (let i=0;i<s.length;i++){
    const ch = s[i];
    if (/[A-Za-z]/.test(ch)) out.push({type:'VAR', val: ch.toUpperCase()});
    else if (ch === '+') out.push({type:'OR'});
    else if (ch === '(') out.push({type:'LP'});
    else if (ch === ')') out.push({type:'RP'});
    else if (ch === "'") out.push({type:'NOT'});
    else {
      // ignore unknown chars (could also throw)
    }
  }
  return out;
}

function parseExpression(tokens){
  // Expression := Term ( '+' Term )*
  let node = parseTerm(tokens);
  while (tokens[0] && tokens[0].type === 'OR'){
    tokens.shift(); // consume +
    const right = parseTerm(tokens);
    node = {type:'OR', left: node, right: right};
  }
  return node;
}

function parseTerm(tokens){
  // Term := Factor ( Factor )*  (adjacency = AND)
  let node = parseFactor(tokens);
  while (tokens[0] && (tokens[0].type === 'VAR' || tokens[0].type === 'LP')){
    const right = parseFactor(tokens);
    node = {type:'AND', left: node, right: right};
  }
  return node;
}

function parseFactor(tokens){
  // Factor := VAR ['] | '(' Expression ')' [']
  if (!tokens[0]) throw new Error("Unexpected end of expression");
  if (tokens[0].type === 'VAR'){
    const v = {type:'VAR', name: tokens.shift().val};
    if (tokens[0] && tokens[0].type === 'NOT'){
      tokens.shift();
      return {type:'NOT', child: v};
    }
    return v;
  }
  if (tokens[0].type === 'LP'){
    tokens.shift(); // (
    const node = parseExpression(tokens);
    if (!tokens[0] || tokens[0].type !== 'RP') throw new Error("Missing closing )");
    tokens.shift(); // )
    if (tokens[0] && tokens[0].type === 'NOT'){ tokens.shift(); return {type:'NOT', child: node}; }
    return node;
  }
  throw new Error("Unexpected token: " + JSON.stringify(tokens[0]));
}

/* ---------------------------
   Layout & Render to SVG
----------------------------*/

function measureWidth(node){
  // Return approximate width required for subtree
  if (!node) return 60;
  switch(node.type){
    case 'VAR': return 60;
    case 'NOT': return measureWidth(node.child) + 40;
    case 'AND':
    case 'OR':
      // left + gate + right + spacing
      return measureWidth(node.left) + 140 + measureWidth(node.right);
    default: return 80;
  }
}

function createSVG(tag, attrs){
  const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
  if (attrs) for (const k in attrs) el.setAttribute(k, attrs[k]);
  return el;
}

function renderGate(svg, type, x, y, id){
  // returns {inX,inY,outX,outY, width, height, element}
  if (type === 'AND'){
    const w = 80, h=60;
    const g = createSVG('g',{id});
    const rect = createSVG('rect',{x:x, y:y-h/2, width:w/2, height:h, rx:10, fill:'var(--gate-fill)',stroke:'#333','stroke-width':2});
    const arc = createSVG('path',{d:`M ${x + w/2} ${y-h/2} Q ${x + w*0.95} ${y} ${x + w/2} ${y+h/2}`, fill:'var(--gate-fill)', stroke:'#333','stroke-width':2});
    const in1 = {x:x-20, y:y-15}, in2 = {x:x-20, y:y+15}, out = {x:x + w + 8, y:y};
    const l1 = createSVG('line',{x1:in1.x,x2:in1.x+18,y1:in1.y,y2:in1.y, stroke: 'var(--wire)','stroke-width':2});
    const l2 = createSVG('line',{x1:in2.x,x2:in2.x+18,y1:in2.y,y2:in2.y, stroke: 'var(--wire)','stroke-width':2});
    const lout = createSVG('line',{x1:x + w/2 + 8, x2:out.x, y1:out.y, y2:out.y, stroke: 'var(--wire)','stroke-width':2});
    const gateLabel = createSVG('text',{x:x + w/2, y:y+6,'text-anchor':'middle', 'font-size':12, 'font-family':'Arial', fill:'#111'}); gateLabel.textContent='AND';
    [rect, arc, l1, l2, lout, gateLabel].forEach(el=>g.appendChild(el));
    svg.appendChild(g);
    return {in: [in1,in2], out: out, w: w+28, h:h, g};
  } else if (type === 'OR'){
    const w=100,h=64;
    const g = createSVG('g',{id});
    // OR shape using two paths
    const tail = createSVG('path',{d:`M ${x-10} ${y-h/2} Q ${x+40} ${y} ${x-10} ${y+h/2}`, fill:'none', stroke:'#333','stroke-width':2});
    const main = createSVG('path',{d:`M ${x+30} ${y-h/2} Q ${x+w*0.8} ${y-h/8} ${x + w/2} ${y} Q ${x+w*0.8} ${y+h/8} ${x+30} ${y+h/2} Q ${x+10} ${y} ${x+30} ${y-h/2}`,'stroke':'#333','stroke-width':2,'fill':'var(--gate-fill)'});
    const in1 = {x:x-28,y:y-18}, in2 = {x:x-28,y:y+18}, out = {x:x + w + 8, y:y};
    const l1 = createSVG('line',{x1:in1.x,x2:x1x=in1.x+22,y1:in1.y,y2:in1.y, stroke:'var(--wire)','stroke-width':2});
    const l2 = createSVG('line',{x1:in2.x,x2:in2.x+22,y1:in2.y,y2:in2.y, stroke:'var(--wire)','stroke-width':2});
    const lout = createSVG('line',{x1:x + w*0.9,x2:out.x,y1:out.y,y2:out.y, stroke:'var(--wire)','stroke-width':2});
    const gateLabel = createSVG('text',{x:x + w/2 - 6, y:y+6,'text-anchor':'middle','font-size':12,'font-family':'Arial',fill:'#111'}); gateLabel.textContent='OR';
    [tail, main, l1, l2, lout, gateLabel].forEach(el=>g.appendChild(el));
    svg.appendChild(g);
    return {in:[in1,in2], out:out, w:w+48,h:h,g};
  } else if (type === 'NOT'){
    // draw inverter triangle + circle
    const w=36,h=36;
    const g=createSVG('g',{id});
    const tri = createSVG('path',{d:`M ${x} ${y-h/2} L ${x} ${y+h/2} L ${x+24} ${y} Z`, fill:'var(--gate-fill)', stroke:'#333','stroke-width':2});
    const circ = createSVG('circle',{cx:x+28, cy:y, r:6, fill:varOr('#fff','var(--gate-fill)'), stroke:'#333','stroke-width':2});
    const in1={x:x-26,y:y}, out={x:x+36,y:y};
    const lin = createSVG('line',{x1:in1.x,x2:x-4,y1:in1.y,y2:in1.y,stroke:'var(--wire)','stroke-width':2});
    const lout = createSVG('line',{x1:x+34,x2:out.x,y1:out.y,y2:out.y,stroke:'var(--wire)','stroke-width':2});
    const gateLabel = createSVG('text',{x:x+12,y:y+26,'text-anchor':'middle','font-size':11,'font-family':'Arial',fill:'#333'}); gateLabel.textContent='NOT';
    [tri,circ,lin,lout,gateLabel].forEach(el=>g.appendChild(el));
    svg.appendChild(g);
    return {in:[in1], out:out, w:w+36, h:h, g};
  }
}

// helper for fallback fill value in create
function varOr(a,b){ return a? a : b; }

/* Actually render the AST recursively in left->right layout */
function renderAST(svg, node, startX, centerY){
  if (!node) return {inPoints:[], outPoint:{x:startX,y:centerY}, width:0};

  if (node.type === 'VAR'){
    // draw variable as labeled circle + short wire
    const g = createSVG('g',{id:'var-'+node.name+'-'+Math.random().toString(36).slice(2,7)});
    const inX = startX, y=centerY;
    const text = createSVG('text',{x:inX+14,y:y+6,'font-family':'Arial','font-size':14, 'font-weight':600, fill:'#111'}); text.textContent = node.name;
    const circle = createSVG('rect',{x:inX+4,y:y-12, width:36, height:28, rx:8, fill:'var(--gate-fill)', stroke:'#333','stroke-width':1.5});
    const line = createSVG('line',{x1:inX, x2:inX+4, y1:y, y2:y, stroke:'var(--wire)','stroke-width':2});
    [line,circle,text].forEach(el=>g.appendChild(el));
    svg.appendChild(g);
    return {inPoints:[{x:inX,y:y}], outPoint:{x:inX+44,y:y}, width:60};
  }

  if (node.type === 'NOT'){
    // render child, then place NOT gate on the right of it
    const child = renderAST(svg, node.child, startX, centerY);
    const gateX = child.outPoint.x + 18;
    const gate = renderNot(svg, gateX, centerY);
    // draw connector from child.outPoint to gate.in
    const conn = createSVG('line',{x1:child.outPoint.x, x2:gate.in.x, y1:centerY, y2:centerY, stroke:'var(--wire)','stroke-width':2});
    svg.appendChild(conn);
    return {inPoints: child.inPoints, outPoint: gate.out, width: child.width + 60};
  }

  if (node.type === 'AND' || node.type === 'OR'){
    // render left subtree
    const left = renderAST(svg, node.left, startX, centerY - 40);
    // render right subtree
    const right = renderAST(svg, node.right, Math.max(left.outPoint.x + 20, startX + left.width + 20), centerY + 40);
    // gate position roughly between them
    const gateX = Math.max(left.outPoint.x, right.outPoint.x) + 30;
    const gate = (node.type === 'AND') ? renderAnd(svg, gateX, centerY) : renderOr(svg, gateX, centerY);
    // wires from children to gate
    // from left.out -> gate.in[0]
    const lwire = createSVG('path',{d:`M ${left.outPoint.x} ${left.outPoint.y} C ${left.outPoint.x+20} ${left.outPoint.y} ${gate.in[0].x-20} ${gate.in[0].y} ${gate.in[0].x} ${gate.in[0].y}`, stroke:'var(--wire)','stroke-width':2, fill:'none'});
    const rwire = createSVG('path',{d:`M ${right.outPoint.x} ${right.outPoint.y} C ${right.outPoint.x+20} ${right.outPoint.y} ${gate.in[1].x-20} ${gate.in[1].y} ${gate.in[1].x} ${gate.in[1].y}`, stroke:'var(--wire)','stroke-width':2, fill:'none'});
    svg.appendChild(lwire); svg.appendChild(rwire);
    return {inPoints: left.inPoints.concat(right.inPoints), outPoint: gate.out, width: (gateX + 80) - startX};
  }

  // fallback: treat unknown node as var
  return renderAST(svg, {type:'VAR', name:'X'}, startX, centerY);
}

/* Gate render helpers that return positions for connections */
function renderAnd(svg, x, y){
  const id = 'and-'+Math.random().toString(36).slice(2,6);
  // draw simplified AND: rectangle+arc
  const w=80,h=56;
  const group = createSVG('g',{id});
  const rect = createSVG('rect',{x:x, y:y-h/2, width:w/2, height:h, rx:10, fill:'var(--gate-fill)',stroke:'#333','stroke-width':2});
  const arc = createSVG('path',{d:`M ${x + w/2} ${y-h/2} Q ${x + w*0.95} ${y} ${x + w/2} ${y+h/2}`, fill:'var(--gate-fill)', stroke:'#333','stroke-width':2});
  group.appendChild(rect); group.appendChild(arc);
  svg.appendChild(group);
  // in points
  const in1 = {x:x-8, y:y-12}, in2 = {x:x-8, y:y+12}, out = {x:x + w + 6, y:y};
  // small lines to show incoming
  const l1 = createSVG('line',{x1:in1.x,x2:x+4,y1:in1.y,y2:in1.y, stroke:'var(--wire)','stroke-width':2});
  const l2 = createSVG('line',{x1:in2.x,x2:x+4,y1:in2.y,y2:in2.y, stroke:'var(--wire)','stroke-width':2});
  const outl = createSVG('line',{x1:x + w/2 + 8, x2:out.x, y1:out.y, y2:out.y, stroke:'var(--wire)','stroke-width':2});
  svg.appendChild(l1); svg.appendChild(l2); svg.appendChild(outl);
  // label
  const lab = createSVG('text',{x:x + w/2, y:y+6,'text-anchor':'middle','font-size':12,'font-family':'Arial',fill:'#222'}); lab.textContent='AND';
  svg.appendChild(lab);
  return {in:[in1,in2], out:out};
}

function renderOr(svg, x, y){
  const id = 'or-'+Math.random().toString(36).slice(2,6);
  const group = createSVG('g',{id});
  const w=100,h=64;
  // main OR body
  const main = createSVG('path',{d:`M ${x+30} ${y-h/2} Q ${x+w*0.8} ${y-h/8} ${x + w/2} ${y} Q ${x+w*0.8} ${y+h/8} ${x+30} ${y+h/2} Q ${x+10} ${y} ${x+30} ${y-h/2}`, 'stroke':'#333','stroke-width':2,'fill':'var(--gate-fill)'});
  const tail = createSVG('path',{d:`M ${x-12} ${y-h/2} Q ${x+40} ${y} ${x-12} ${y+h/2}`, fill:'none', stroke:'#333','stroke-width':2});
  group.appendChild(main); group.appendChild(tail);
  svg.appendChild(group);
  const in1 = {x:x-24, y:y-18}, in2 = {x:x-24, y:y+18}, out = {x:x + w + 8, y:y};
  const l1 = createSVG('line',{x1:in1.x,x2:in1.x+22,y1:in1.y,y2:in1.y, stroke:'var(--wire)','stroke-width':2});
  const l2 = createSVG('line',{x1:in2.x,x2:in2.x+22,y1:in2.y,y2:in2.y, stroke:'var(--wire)','stroke-width':2});
  const lout = createSVG('line',{x1:x + w*0.9,x2:out.x,y1:out.y,y2:out.y, stroke:'var(--wire)','stroke-width':2});
  svg.appendChild(l1); svg.appendChild(l2); svg.appendChild(lout);
  const lab = createSVG('text',{x:x + w/2 - 6, y:y+6,'text-anchor':'middle','font-size':12,'font-family':'Arial',fill:'#222'}); lab.textContent='OR';
  svg.appendChild(lab);
  return {in:[in1,in2], out:out};
}

function renderNot(svg, x, y){
  const g = createSVG('g',{id:'not-'+Math.random().toString(36).slice(2,6)});
  const tri = createSVG('path',{d:`M ${x} ${y-18} L ${x} ${y+18} L ${x+24} ${y} Z`, fill:'var(--gate-fill)', stroke:'#333','stroke-width':2});
  const circ = createSVG('circle',{cx:x+28, cy:y, r:6, fill:'#fff', stroke:'#333','stroke-width':2});
  const lin = createSVG('line',{x1:x-20,x2:x-4,y1:y,y2:y, stroke:'var(--wire)','stroke-width':2});
  const lout = createSVG('line',{x1:x+34,x2:x+48,y1:y,y2:y, stroke:'var(--wire)','stroke-width':2});
  svg.appendChild(g); g.appendChild(tri); g.appendChild(circ); g.appendChild(lin); g.appendChild(lout);
  const lab = createSVG('text',{x:x+12,y:y+26,'text-anchor':'middle','font-size':11,'font-family':'Arial',fill:'#222'}); lab.textContent='NOT';
  g.appendChild(lab);
  return {in:{x:x-20,y:y}, out:{x:x+48,y:y}};
}

/* ---------------------------
   Public convert function
----------------------------*/
function convertAndRender(expr){
  const svg = document.getElementById('circuitSVG');
  // clear svg
  while (svg.firstChild) svg.removeChild(svg.firstChild);

  // tokenize & parse
  let tokens, ast;
  try {
    tokens = tokenize(expr);
    const tcopy = tokens.slice();
    ast = parseExpression(tcopy);
    if (tcopy.length) throw new Error("Unexpected token after end");
  } catch (e){
    const err = createSVG('text',{x:20,y:30,fill:'#b30000','font-family':'Arial'}); err.textContent = "Parse error: " + e.message;
    svg.appendChild(err);
    return;
  }

  // layout estimation
  const totalWidth = Math.max(1000, measureWidth(ast));
  const marginX = 20;
  const centerY = 200;
  svg.setAttribute('viewBox', `0 0 ${Math.max(totalWidth + marginX*2, 1100)} 400`);

  // render recursively starting at left margin
  try {
    renderAST(svg, ast, marginX + 20, centerY);
  } catch (err) {
    const errEl = createSVG('text',{x:20,y:30,fill:'#b30000','font-family':'Arial'}); errEl.textContent = "Render error: " + err.message;
    svg.appendChild(errEl);
  }
}

/* ---------------------------
   Bind UI
----------------------------*/
$(function(){
  $('#btnConvert').on('click', function(){
    const expr = $('#expr').val().trim();
    if (!expr){ alert('Enter a Boolean expression.'); return; }
    convertAndRender(expr);
  });

  $('#btnClear').on('click', function(){
    $('#expr').val('');
    const svg = document.getElementById('circuitSVG');
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  });

  $('#btnDownload').on('click', function(){
    const svgEl = document.getElementById('circuitSVG');
    const serializer = new XMLSerializer();
    const svgStr = serializer.serializeToString(svgEl);
    const blob = new Blob([svgStr], {type: 'image/svg+xml'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'circuit.svg';
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  });

  // initial render
  convertAndRender($('#expr').val());
});
</script>
</body>
</html>